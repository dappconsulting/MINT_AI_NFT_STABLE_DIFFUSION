import{RELAYER_EVENTS as J,RELAYER_DEFAULT_PROTOCOL as F,Core as X,Store as R}from"@walletconnect/core";import{getDefaultLoggerOptions as H,generateChildLogger as Y,getLoggerContext as k}from"@walletconnect/logger";import{EventEmitter as B}from"events";import G from"pino";import{formatJsonRpcRequest as Z,formatJsonRpcResult as Q,formatJsonRpcError as W,isJsonRpcResult as ee,isJsonRpcError as te,isJsonRpcRequest as ie,isJsonRpcResponse as se}from"@walletconnect/jsonrpc-utils";import{ONE_DAY as v,FIVE_MINUTES as re}from"@walletconnect/time";import{isValidUrl as ne,calcExpiry as oe,generateRandomBytes32 as ae,hashKey as C,formatUri as ce,getInternalError as le,TYPE_1 as he}from"@walletconnect/utils";import{hashMessage as P}from"@ethersproject/hash";import{recoverAddress as ue}from"@ethersproject/transactions";import de from"isomorphic-unfetch";import{randomStringForEntropy as pe}from"@stablelib/random";class O{constructor(i){this.client=i}}class L{constructor(i){this.opts=i}}const N="https://rpc.walletconnect.com/v1",y={wc_authRequest:{req:{ttl:v,prompt:!0,tag:3e3},res:{ttl:v,prompt:!1,tag:3001}}},q="wc",S=1,x="auth",I="authClient",m=`${q}@${1}:${x}:`,E=`${m}:PUB_KEY`,ge="expirer",ye={created:"expirer_created",deleted:"expirer_deleted",expired:"expirer_expired",sync:"expirer_sync"},me="0.3",we=v;function _(r){return r?.split(":")}function Ee(r){const i=r&&_(r);if(i)return i[3]}function fe(r){const i=r&&_(r);if(i)return i[2]+":"+i[3]}function K(r){const i=r&&_(r);if(i)return i.pop()}function $(r){return r.getAll().filter(i=>"requester"in i)}function U(r,i){return $(r).find(e=>e.id===i)}function Re(r){const i=ne(r.aud),e=new RegExp(`${r.domain}`).test(r.aud),t=!!r.nonce,s=r.type?r.type==="eip4361":!0;return!!(i&&e&&t&&s)}function ve(r,i){return!!U(i,r.id)}async function qe(r,i,e,t,s){switch(e.t){case"eip191":return Ie(r,i,e.s);case"eip1271":return await _e(r,i,e.s,t,s);default:throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${e.t}`)}}function Ie(r,i,e){return ue(P(i),e).toLowerCase()===r.toLowerCase()}async function _e(r,i,e,t,s){try{const n="0x1626ba7e",o="0000000000000000000000000000000000000000000000000000000000000040",a="0000000000000000000000000000000000000000000000000000000000000041",l=e.substring(2),c=P(i).substring(2),u=n+c+o+a+l,d=await de(`${N}/?chainId=${t}&projectId=${s}`,{method:"POST",body:JSON.stringify({id:Te(),jsonrpc:"2.0",method:"eth_call",params:[{to:r,data:u},"latest"]})}),{result:h}=await d.json();return h?h.slice(0,n.length).toLowerCase()===n.toLowerCase():!1}catch(n){return console.error("isValidEip1271Signature: ",n),!1}}function Te(){return Date.now()+Math.floor(Math.random()*1e3)}var be=Object.defineProperty,D=Object.getOwnPropertySymbols,Ae=Object.prototype.hasOwnProperty,Ce=Object.prototype.propertyIsEnumerable,j=(r,i,e)=>i in r?be(r,i,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[i]=e,z=(r,i)=>{for(var e in i||(i={}))Ae.call(i,e)&&j(r,e,i[e]);if(D)for(var e of D(i))Ce.call(i,e)&&j(r,e,i[e]);return r};class Pe extends O{constructor(i){super(i),this.initialized=!1,this.name="authEngine",this.init=()=>{this.initialized||(this.registerRelayerEvents(),this.client.core.pairing.register({methods:Object.keys(y)}),this.initialized=!0)},this.request=async(e,t)=>{if(this.isInitialized(),!Re(e))throw new Error("Invalid request");const{chainId:s,statement:n,aud:o,domain:a,nonce:l,type:c}=e,u=Boolean(t?.topic)&&this.client.core.pairing.pairings.getAll({active:!0}).some(w=>w.topic===t?.topic),d={protocol:F},h=oe(re),g=await this.client.core.crypto.generateKeyPair();if(u){const w=this.client.core.pairing.pairings.getAll({active:!0}).find(V=>V.topic===t?.topic);if(!w)throw new Error(`Could not find pairing for provided topic ${t?.topic}`);await this.sendRequest(w.topic,"wc_authRequest",{payloadParams:{type:c??"eip4361",chainId:s,statement:n,aud:o,domain:a,version:"1",nonce:l,iat:new Date().toISOString()},requester:{publicKey:g,metadata:this.client.metadata}}),this.client.logger.debug("sent request to existing pairing")}const T=ae(),p=await this.client.core.crypto.setSymKey(T),b={topic:p,expiry:h,relay:d,active:!1};await this.client.core.pairing.pairings.set(p,b),this.client.logger.debug("Generated new pairing",b),this.setExpiry(p,h),this.client.authKeys.set(E,{publicKey:g});const A=C(g);await this.client.pairingTopics.set(A,{pairingTopic:p}),await this.client.core.relayer.subscribe(p),await this.client.core.relayer.subscribe(A),this.client.logger.debug("sending request to potential pairing");const M=await this.sendRequest(p,"wc_authRequest",{payloadParams:{type:c??"eip4361",chainId:s,statement:n,aud:o,domain:a,version:"1",nonce:l,iat:new Date().toISOString()},requester:{publicKey:g,metadata:this.client.metadata}});return this.client.logger.debug("sent request to potential pairing"),{uri:ce({protocol:this.client.protocol,version:this.client.core.version,topic:p,symKey:T,relay:d}),id:M}},this.respond=async e=>{if(this.isInitialized(),!ve(e,this.client.requests))throw new Error("Invalid response");const t=U(this.client.requests,e.id),s=t.requester.publicKey,n=await this.client.core.crypto.generateKeyPair(),o=C(s),a={type:he,receiverPublicKey:s,senderPublicKey:n};if("error"in e){await this.sendError(t.id,o,e,a);return}const l={h:{t:"eip4361"},p:t.cacaoPayload,s:e.signature},c=await this.sendResult(t.id,o,l,a);await this.client.requests.set(c,z({id:c},l))},this.getPendingRequests=()=>$(this.client.requests),this.setExpiry=async(e,t)=>{this.client.core.pairing.pairings.keys.includes(e)&&await this.client.core.pairing.updateExpiry({topic:e,expiry:t}),this.client.core.expirer.set(e,t)},this.sendRequest=async(e,t,s,n)=>{const o=Z(t,s),a=await this.client.core.crypto.encode(e,o,n),l=y[t].req;return this.client.core.history.set(e,o),await this.client.core.relayer.publish(e,a,l),o.id},this.sendResult=async(e,t,s,n)=>{const o=Q(e,s),a=await this.client.core.crypto.encode(t,o,n),l=await this.client.core.history.get(t,e),c=y[l.request.method].res;return await this.client.core.relayer.publish(t,a,c),await this.client.core.history.resolve(o),o.id},this.sendError=async(e,t,s,n)=>{const o=W(e,s.error),a=await this.client.core.crypto.encode(t,o,n),l=await this.client.core.history.get(t,e),c=y[l.request.method].res;return await this.client.core.relayer.publish(t,a,c),await this.client.core.history.resolve(o),o.id},this.onRelayEventRequest=e=>{const{topic:t,payload:s}=e,n=s.method;switch(n){case"wc_authRequest":return this.onAuthRequest(t,s);default:return this.client.logger.info(`Unsupported request method ${n}`)}},this.onRelayEventResponse=async e=>{const{topic:t,payload:s}=e,n=(await this.client.core.history.get(t,s.id)).request.method;switch(n){case"wc_authRequest":return this.onAuthResponse(t,s);default:return this.client.logger.info(`Unsupported response method ${n}`)}},this.constructEip4361Message=e=>{this.client.logger.debug("constructEip4361Message, cacao is:",e);const t=`${e.domain} wants you to sign in with your Ethereum account:`,s=K(e.iss),n=e.statement,o=`URI: ${e.aud}`,a=`Version: ${e.version}`,l=`Chain ID: ${Ee(e.iss)}`,c=`Nonce: ${e.nonce}`,u=`Issued At: ${e.iat}`,d=e.resources&&e.resources.length>0?`Resources:
${e.resources.map(h=>`- ${h}`).join(`
`)}`:void 0;return[t,s,"",n,"",o,a,l,c,u,d].filter(h=>h!=null).join(`
`)},this.onAuthRequest=async(e,t)=>{const{requester:s,payloadParams:{resources:n,statement:o,aud:a,domain:l,version:c,nonce:u,iat:d}}=t.params;this.client.logger.debug("onAuthRequest:",e,t);try{const h={iss:this.client.address||"",aud:a,domain:l,version:c,nonce:u,iat:d,statement:o,resources:n},g=this.constructEip4361Message(h);await this.client.requests.set(t.id,{requester:s,id:t.id,message:g,cacaoPayload:h}),this.client.emit("auth_request",{id:t.id,topic:e,params:{requester:s,message:this.constructEip4361Message(h)}})}catch(h){await this.sendError(t.id,e,h),this.client.logger.error(h)}},this.onAuthResponse=async(e,t)=>{const{id:s}=t;if(this.client.logger.debug("onAuthResponse",e,t),ee(t)){const{pairingTopic:n}=this.client.pairingTopics.get(e);await this.client.core.pairing.activate({topic:n});const{s:o,p:a}=t.result;await this.client.requests.set(s,z({id:s},t.result));const l=this.constructEip4361Message(a);this.client.logger.debug(`reconstructed message:
`,JSON.stringify(l)),this.client.logger.debug("payload.iss:",a.iss),this.client.logger.debug("signature:",o);const c=K(a.iss),u=fe(a.iss);if(!c)throw new Error("Could not derive address from `payload.iss`");if(!u)throw new Error("Could not derive chainId from `payload.iss`");this.client.logger.debug("walletAddress extracted from `payload.iss`:",c),await qe(c,l,o,u,this.client.projectId)?this.client.emit("auth_response",{id:s,topic:e,params:t}):this.client.emit("auth_response",{id:s,topic:e,params:{message:"Invalid signature",code:-1}})}else te(t)&&this.client.emit("auth_response",{id:s,topic:e,params:t})}}isInitialized(){if(!this.initialized){const{message:i}=le("NOT_INITIALIZED",this.name);throw new Error(i)}}registerRelayerEvents(){this.client.core.relayer.on(J.message,async i=>{const{topic:e,message:t}=i,s=this.client.authKeys.keys.includes(E)?this.client.authKeys.get(E).publicKey:"",n=s?{receiverPublicKey:s}:{},o=await this.client.core.crypto.decode(e,t,n);ie(o)?(this.client.core.history.set(e,o),this.onRelayEventRequest({topic:e,payload:o})):se(o)&&(await this.client.core.history.resolve(o),this.onRelayEventResponse({topic:e,payload:o}))})}}class f extends L{constructor(i){super(i),this.protocol=q,this.version=S,this.name=I,this.events=new B,this.emit=(t,s)=>this.events.emit(t,s),this.on=(t,s)=>this.events.on(t,s),this.once=(t,s)=>this.events.once(t,s),this.off=(t,s)=>this.events.off(t,s),this.removeListener=(t,s)=>this.events.removeListener(t,s),this.request=async(t,s)=>{try{return await this.engine.request(t,s)}catch(n){throw this.logger.error(n.message),n}},this.respond=async t=>{try{return await this.engine.respond(t)}catch(s){throw this.logger.error(s.message),s}},this.getPendingRequests=()=>{try{return this.engine.getPendingRequests()}catch(t){throw this.logger.error(t.message),t}};const e=typeof i.logger<"u"&&typeof i.logger!="string"?i.logger:G(H({level:i.logger||"error"}));this.name=i?.name||I,this.metadata=i.metadata,this.address=i.iss,this.projectId=i.projectId,this.core=i.core||new X(i),this.logger=Y(e,this.name),this.authKeys=new R(this.core,this.logger,"authKeys",m),this.pairingTopics=new R(this.core,this.logger,"pairingTopics",m),this.requests=new R(this.core,this.logger,"requests",m),this.engine=new Pe(this)}static async init(i){const e=new f(i);return await e.initialize(),e}get context(){return k(this.logger)}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.authKeys.init(),await this.requests.init(),await this.pairingTopics.init(),await this.engine.init(),this.logger.info("AuthClient Initialization Success")}catch(i){throw this.logger.info("AuthClient Initialization Failure"),this.logger.error(i.message),i}}}function Oe(){return pe(96)}const Le=f;export{x as AUTH_CLIENT_CONTEXT,I as AUTH_CLIENT_DEFAULT_NAME,q as AUTH_CLIENT_PROTOCOL,E as AUTH_CLIENT_PUBLIC_KEY_NAME,m as AUTH_CLIENT_STORAGE_PREFIX,S as AUTH_CLIENT_VERSION,Le as AuthClient,N as DEFAULT_RPC_URL,y as ENGINE_RPC_OPTS,ge as EXPIRER_CONTEXT,we as EXPIRER_DEFAULT_TTL,ye as EXPIRER_EVENTS,me as EXPIRER_STORAGE_VERSION,L as IAuthClient,O as IAuthEngine,f as default,Oe as generateNonce};
//# sourceMappingURL=index.es.js.map
