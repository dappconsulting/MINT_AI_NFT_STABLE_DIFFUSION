import le from"pino";import Nt from"@walletconnect/keyvaluestorage";import{HEARTBEAT_EVENTS as X,HeartBeat as Lt}from"@walletconnect/heartbeat";import{generateChildLogger as v,getLoggerContext as w,getDefaultLoggerOptions as de}from"@walletconnect/logger";import{IMessageTracker as Ut,IPublisher as Ft,ISubscriber as Mt,IRelayer as $t,IStore as Kt,IJsonRpcHistory as kt,IExpirer as Bt,ICore as jt}from"@walletconnect/types";import{safeJsonStringify as Vt,safeJsonParse as qt}from"@walletconnect/safe-json";import*as j from"@walletconnect/relay-auth";import{getInternalError as c,mapToObj as ge,objToMap as pe,generateKeyPair as Gt,generateRandomBytes32 as W,deriveSymKey as Yt,hashKey as Jt,validateEncoding as Ht,isTypeOneEnvelope as De,encrypt as Xt,validateDecoding as Wt,decrypt as Zt,deserialize as Qt,decodeTypeByte as ei,hashMessage as V,getRelayProtocolName as Z,getRelayProtocolApi as Q,isUndefined as ee,getSdkError as M,formatRelayRpcUrl as ti,isProposalStruct as ii,isSessionStruct as si,TYPE_1 as ri,calcExpiry as te,formatUri as ni,parseUri as ai,createDelayedPromise as oi,engineEvent as ie,isExpired as ye,isValidParams as se,isValidUrl as hi,isValidString as ci,parseExpirerTarget as ui,formatTopicTarget as li,formatIdTarget as di}from"@walletconnect/utils";import{ONE_DAY as L,SIX_HOURS as gi,ONE_SECOND as pi,THIRTY_DAYS as re,FIVE_SECONDS as Di,THIRTY_SECONDS as fe,Watch as yi,toMiliseconds as me,FIVE_MINUTES as be}from"@walletconnect/time";import{JsonRpcProvider as fi}from"@walletconnect/jsonrpc-provider";import{isJsonRpcRequest as Ee,formatJsonRpcResult as ve,formatJsonRpcRequest as we,formatJsonRpcError as mi,isJsonRpcResult as bi,isJsonRpcError as _e,isJsonRpcResponse as Ei}from"@walletconnect/jsonrpc-utils";import vi from"@walletconnect/jsonrpc-ws-connection";import wi from"lodash.isequal";function p(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}var z=p;p.EventEmitter=p,p.prototype._events=void 0,p.prototype._maxListeners=void 0,p.defaultMaxListeners=10,p.prototype.setMaxListeners=function(r){if(!_i(r)||r<0||isNaN(r))throw TypeError("n must be a positive number");return this._maxListeners=r,this},p.prototype.emit=function(r){var e,t,i,s,n,a;if(this._events||(this._events={}),r==="error"&&(!this._events.error||$(this._events.error)&&!this._events.error.length)){if(e=arguments[1],e instanceof Error)throw e;var o=new Error('Uncaught, unspecified "error" event. ('+e+")");throw o.context=e,o}if(t=this._events[r],Ie(t))return!1;if(T(t))switch(arguments.length){case 1:t.call(this);break;case 2:t.call(this,arguments[1]);break;case 3:t.call(this,arguments[1],arguments[2]);break;default:s=Array.prototype.slice.call(arguments,1),t.apply(this,s)}else if($(t))for(s=Array.prototype.slice.call(arguments,1),a=t.slice(),i=a.length,n=0;n<i;n++)a[n].apply(this,s);return!0},p.prototype.addListener=function(r,e){var t;if(!T(e))throw TypeError("listener must be a function");return this._events||(this._events={}),this._events.newListener&&this.emit("newListener",r,T(e.listener)?e.listener:e),this._events[r]?$(this._events[r])?this._events[r].push(e):this._events[r]=[this._events[r],e]:this._events[r]=e,$(this._events[r])&&!this._events[r].warned&&(Ie(this._maxListeners)?t=p.defaultMaxListeners:t=this._maxListeners,t&&t>0&&this._events[r].length>t&&(this._events[r].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[r].length),typeof console.trace=="function"&&console.trace())),this},p.prototype.on=p.prototype.addListener,p.prototype.once=function(r,e){if(!T(e))throw TypeError("listener must be a function");var t=!1;function i(){this.removeListener(r,i),t||(t=!0,e.apply(this,arguments))}return i.listener=e,this.on(r,i),this},p.prototype.removeListener=function(r,e){var t,i,s,n;if(!T(e))throw TypeError("listener must be a function");if(!this._events||!this._events[r])return this;if(t=this._events[r],s=t.length,i=-1,t===e||T(t.listener)&&t.listener===e)delete this._events[r],this._events.removeListener&&this.emit("removeListener",r,e);else if($(t)){for(n=s;n-- >0;)if(t[n]===e||t[n].listener&&t[n].listener===e){i=n;break}if(i<0)return this;t.length===1?(t.length=0,delete this._events[r]):t.splice(i,1),this._events.removeListener&&this.emit("removeListener",r,e)}return this},p.prototype.removeAllListeners=function(r){var e,t;if(!this._events)return this;if(!this._events.removeListener)return arguments.length===0?this._events={}:this._events[r]&&delete this._events[r],this;if(arguments.length===0){for(e in this._events)e!=="removeListener"&&this.removeAllListeners(e);return this.removeAllListeners("removeListener"),this._events={},this}if(t=this._events[r],T(t))this.removeListener(r,t);else if(t)for(;t.length;)this.removeListener(r,t[t.length-1]);return delete this._events[r],this},p.prototype.listeners=function(r){var e;return!this._events||!this._events[r]?e=[]:T(this._events[r])?e=[this._events[r]]:e=this._events[r].slice(),e},p.prototype.listenerCount=function(r){if(this._events){var e=this._events[r];if(T(e))return 1;if(e)return e.length}return 0},p.listenerCount=function(r,e){return r.listenerCount(e)};function T(r){return typeof r=="function"}function _i(r){return typeof r=="number"}function $(r){return typeof r=="object"&&r!==null}function Ie(r){return r===void 0}function Ii(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),i=0;i<t.length;i++)t[i]=255;for(var s=0;s<r.length;s++){var n=r.charAt(s),a=n.charCodeAt(0);if(t[a]!==255)throw new TypeError(n+" is ambiguous");t[a]=s}var o=r.length,h=r.charAt(0),l=Math.log(o)/Math.log(256),d=Math.log(256)/Math.log(o);function g(u){if(u instanceof Uint8Array||(ArrayBuffer.isView(u)?u=new Uint8Array(u.buffer,u.byteOffset,u.byteLength):Array.isArray(u)&&(u=Uint8Array.from(u))),!(u instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(u.length===0)return"";for(var y=0,A=0,b=0,I=u.length;b!==I&&u[b]===0;)b++,y++;for(var C=(I-b)*d+1>>>0,f=new Uint8Array(C);b!==I;){for(var R=u[b],P=0,E=C-1;(R!==0||P<A)&&E!==-1;E--,P++)R+=256*f[E]>>>0,f[E]=R%o>>>0,R=R/o>>>0;if(R!==0)throw new Error("Non-zero carry");A=P,b++}for(var S=C-A;S!==C&&f[S]===0;)S++;for(var B=h.repeat(y);S<C;++S)B+=r.charAt(f[S]);return B}function k(u){if(typeof u!="string")throw new TypeError("Expected String");if(u.length===0)return new Uint8Array;var y=0;if(u[y]!==" "){for(var A=0,b=0;u[y]===h;)A++,y++;for(var I=(u.length-y)*l+1>>>0,C=new Uint8Array(I);u[y];){var f=t[u.charCodeAt(y)];if(f===255)return;for(var R=0,P=I-1;(f!==0||R<b)&&P!==-1;P--,R++)f+=o*C[P]>>>0,C[P]=f%256>>>0,f=f/256>>>0;if(f!==0)throw new Error("Non-zero carry");b=R,y++}if(u[y]!==" "){for(var E=I-b;E!==I&&C[E]===0;)E++;for(var S=new Uint8Array(A+(I-E)),B=A;E!==I;)S[B++]=C[E++];return S}}}function H(u){var y=k(u);if(y)return y;throw new Error(`Non-${e} character`)}return{encode:g,decodeUnsafe:k,decode:H}}var Ci=Ii,Ri=Ci;const Ce=r=>{if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")},Si=r=>new TextEncoder().encode(r),Ti=r=>new TextDecoder().decode(r);class xi{constructor(e,t,i){this.name=e,this.prefix=t,this.baseEncode=i}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class Pi{constructor(e,t,i){if(this.name=e,this.prefix=t,t.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=i}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return Re(this,e)}}class Oi{constructor(e){this.decoders=e}or(e){return Re(this,e)}decode(e){const t=e[0],i=this.decoders[t];if(i)return i.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const Re=(r,e)=>new Oi({...r.decoders||{[r.prefix]:r},...e.decoders||{[e.prefix]:e}});class Ai{constructor(e,t,i,s){this.name=e,this.prefix=t,this.baseEncode=i,this.baseDecode=s,this.encoder=new xi(e,t,i),this.decoder=new Pi(e,t,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const q=({name:r,prefix:e,encode:t,decode:i})=>new Ai(r,e,t,i),K=({prefix:r,name:e,alphabet:t})=>{const{encode:i,decode:s}=Ri(t,e);return q({prefix:r,name:e,encode:i,decode:n=>Ce(s(n))})},zi=(r,e,t,i)=>{const s={};for(let d=0;d<e.length;++d)s[e[d]]=d;let n=r.length;for(;r[n-1]==="=";)--n;const a=new Uint8Array(n*t/8|0);let o=0,h=0,l=0;for(let d=0;d<n;++d){const g=s[r[d]];if(g===void 0)throw new SyntaxError(`Non-${i} character`);h=h<<t|g,o+=t,o>=8&&(o-=8,a[l++]=255&h>>o)}if(o>=t||255&h<<8-o)throw new SyntaxError("Unexpected end of data");return a},Ni=(r,e,t)=>{const i=e[e.length-1]==="=",s=(1<<t)-1;let n="",a=0,o=0;for(let h=0;h<r.length;++h)for(o=o<<8|r[h],a+=8;a>t;)a-=t,n+=e[s&o>>a];if(a&&(n+=e[s&o<<t-a]),i)for(;n.length*t&7;)n+="=";return n},D=({name:r,prefix:e,bitsPerChar:t,alphabet:i})=>q({prefix:e,name:r,encode(s){return Ni(s,i,t)},decode(s){return zi(s,i,t,r)}}),Li=q({prefix:"\0",name:"identity",encode:r=>Ti(r),decode:r=>Si(r)});var Ui=Object.freeze({__proto__:null,identity:Li});const Fi=D({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var Mi=Object.freeze({__proto__:null,base2:Fi});const $i=D({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var Ki=Object.freeze({__proto__:null,base8:$i});const ki=K({prefix:"9",name:"base10",alphabet:"0123456789"});var Bi=Object.freeze({__proto__:null,base10:ki});const ji=D({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Vi=D({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var qi=Object.freeze({__proto__:null,base16:ji,base16upper:Vi});const Gi=D({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Yi=D({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Ji=D({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Hi=D({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Xi=D({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Wi=D({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Zi=D({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Qi=D({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),es=D({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var ts=Object.freeze({__proto__:null,base32:Gi,base32upper:Yi,base32pad:Ji,base32padupper:Hi,base32hex:Xi,base32hexupper:Wi,base32hexpad:Zi,base32hexpadupper:Qi,base32z:es});const is=K({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),ss=K({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var rs=Object.freeze({__proto__:null,base36:is,base36upper:ss});const ns=K({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),as=K({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var os=Object.freeze({__proto__:null,base58btc:ns,base58flickr:as});const hs=D({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),cs=D({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),us=D({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),ls=D({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var ds=Object.freeze({__proto__:null,base64:hs,base64pad:cs,base64url:us,base64urlpad:ls});const Se=Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"),gs=Se.reduce((r,e,t)=>(r[t]=e,r),[]),ps=Se.reduce((r,e,t)=>(r[e.codePointAt(0)]=t,r),[]);function Ds(r){return r.reduce((e,t)=>(e+=gs[t],e),"")}function ys(r){const e=[];for(const t of r){const i=ps[t.codePointAt(0)];if(i===void 0)throw new Error(`Non-base256emoji character: ${t}`);e.push(i)}return new Uint8Array(e)}const fs=q({prefix:"\u{1F680}",name:"base256emoji",encode:Ds,decode:ys});var ms=Object.freeze({__proto__:null,base256emoji:fs}),bs=xe,Te=128,Es=127,vs=~Es,ws=Math.pow(2,31);function xe(r,e,t){e=e||[],t=t||0;for(var i=t;r>=ws;)e[t++]=r&255|Te,r/=128;for(;r&vs;)e[t++]=r&255|Te,r>>>=7;return e[t]=r|0,xe.bytes=t-i+1,e}var _s=ne,Is=128,Pe=127;function ne(r,i){var t=0,i=i||0,s=0,n=i,a,o=r.length;do{if(n>=o)throw ne.bytes=0,new RangeError("Could not decode varint");a=r[n++],t+=s<28?(a&Pe)<<s:(a&Pe)*Math.pow(2,s),s+=7}while(a>=Is);return ne.bytes=n-i,t}var Cs=Math.pow(2,7),Rs=Math.pow(2,14),Ss=Math.pow(2,21),Ts=Math.pow(2,28),xs=Math.pow(2,35),Ps=Math.pow(2,42),Os=Math.pow(2,49),As=Math.pow(2,56),zs=Math.pow(2,63),Ns=function(r){return r<Cs?1:r<Rs?2:r<Ss?3:r<Ts?4:r<xs?5:r<Ps?6:r<Os?7:r<As?8:r<zs?9:10},Ls={encode:bs,decode:_s,encodingLength:Ns},Oe=Ls;const Ae=(r,e,t=0)=>(Oe.encode(r,e,t),e),ze=r=>Oe.encodingLength(r),ae=(r,e)=>{const t=e.byteLength,i=ze(r),s=i+ze(t),n=new Uint8Array(s+t);return Ae(r,n,0),Ae(t,n,i),n.set(e,s),new Us(r,t,e,n)};class Us{constructor(e,t,i,s){this.code=e,this.size=t,this.digest=i,this.bytes=s}}const Ne=({name:r,code:e,encode:t})=>new Fs(r,e,t);class Fs{constructor(e,t,i){this.name=e,this.code=t,this.encode=i}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?ae(this.code,t):t.then(i=>ae(this.code,i))}else throw Error("Unknown type, must be binary type")}}const Le=r=>async e=>new Uint8Array(await crypto.subtle.digest(r,e)),Ms=Ne({name:"sha2-256",code:18,encode:Le("SHA-256")}),$s=Ne({name:"sha2-512",code:19,encode:Le("SHA-512")});var Ks=Object.freeze({__proto__:null,sha256:Ms,sha512:$s});const Ue=0,ks="identity",Fe=Ce,Bs=r=>ae(Ue,Fe(r)),js={code:Ue,name:ks,encode:Fe,digest:Bs};var Vs=Object.freeze({__proto__:null,identity:js});new TextEncoder,new TextDecoder;const Me={...Ui,...Mi,...Ki,...Bi,...qi,...ts,...rs,...os,...ds,...ms};({...Ks,...Vs});function qs(r=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?globalThis.Buffer.allocUnsafe(r):new Uint8Array(r)}function $e(r,e,t,i){return{name:r,prefix:e,encoder:{name:r,prefix:e,encode:t},decoder:{decode:i}}}const Ke=$e("utf8","u",r=>{const e=new TextDecoder("utf8");return"u"+e.decode(r)},r=>new TextEncoder().encode(r.substring(1))),oe=$e("ascii","a",r=>{let e="a";for(let t=0;t<r.length;t++)e+=String.fromCharCode(r[t]);return e},r=>{r=r.substring(1);const e=qs(r.length);for(let t=0;t<r.length;t++)e[t]=r.charCodeAt(t);return e}),Gs={utf8:Ke,"utf-8":Ke,hex:Me.base16,latin1:oe,ascii:oe,binary:oe,...Me};function Ys(r,e="utf8"){const t=Gs[e];if(!t)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(r,"utf8"):t.decoder.decode(`${t.prefix}${r}`)}const he="wc",ke=2,G="core",x=`${he}@${2}:${G}:`,Be={name:G,logger:"error"},je={database:":memory:"},Ve="crypto",ce="client_ed25519_seed",qe=L,Ge="keychain",Ye="0.3",Je="messages",He="0.3",Xe=gi,We="publisher",Ze="irn",Qe="error",et="wss://relay.walletconnect.com",tt="relayer",U={message:"relayer_message",connect:"relayer_connect",disconnect:"relayer_disconnect",error:"relayer_error"},it="_subscription",N={payload:"payload",connect:"connect",disconnect:"disconnect",error:"error"},st=pi,Js={database:":memory:"},rt="2.0.0",nt="0.3",O={created:"subscription_created",deleted:"subscription_deleted",expired:"subscription_expired",disabled:"subscription_disabled",sync:"subscription_sync"},Hs=re,at="subscription",ot="0.3",ht=Di*1e3,ct="pairing",ut="0.3",Xs=re,F={wc_pairingDelete:{req:{ttl:L,prompt:!1,tag:1e3},res:{ttl:L,prompt:!1,tag:1001}},wc_pairingPing:{req:{ttl:fe,prompt:!1,tag:1002},res:{ttl:fe,prompt:!1,tag:1003}},unregistered_method:{req:{ttl:L,prompt:!1,tag:0},res:{ttl:L,prompt:!1,tag:0}}},_={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},lt="history",dt="0.3",gt="expirer",m={created:"expirer_created",deleted:"expirer_deleted",expired:"expirer_expired",sync:"expirer_sync"},pt="0.3",Ws=L;class Dt{constructor(e,t){this.core=e,this.logger=t,this.keychain=new Map,this.name=Ge,this.version=Ye,this.initialized=!1,this.storagePrefix=x,this.init=async()=>{if(!this.initialized){const i=await this.getKeyChain();typeof i<"u"&&(this.keychain=i),this.initialized=!0}},this.has=i=>(this.isInitialized(),this.keychain.has(i)),this.set=async(i,s)=>{this.isInitialized(),this.keychain.set(i,s),await this.persist()},this.get=i=>{this.isInitialized();const s=this.keychain.get(i);if(typeof s>"u"){const{message:n}=c("NO_MATCHING_KEY",`${this.name}: ${i}`);throw new Error(n)}return s},this.del=async i=>{this.isInitialized(),this.keychain.delete(i),await this.persist()},this.core=e,this.logger=v(t,this.name)}get context(){return w(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}async setKeyChain(e){await this.core.storage.setItem(this.storageKey,ge(e))}async getKeyChain(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?pe(e):void 0}async persist(){await this.setKeyChain(this.keychain)}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class yt{constructor(e,t,i){this.core=e,this.logger=t,this.name=Ve,this.initialized=!1,this.init=async()=>{this.initialized||(await this.keychain.init(),this.initialized=!0)},this.hasKeys=s=>(this.isInitialized(),this.keychain.has(s)),this.getClientId=async()=>{this.isInitialized();const s=await this.getClientSeed(),n=j.generateKeyPair(s);return j.encodeIss(n.publicKey)},this.generateKeyPair=()=>{this.isInitialized();const s=Gt();return this.setPrivateKey(s.publicKey,s.privateKey)},this.signJWT=async s=>{this.isInitialized();const n=await this.getClientSeed(),a=j.generateKeyPair(n),o=W(),h=qe;return await j.signJWT(o,s,h,a)},this.generateSharedKey=(s,n,a)=>{this.isInitialized();const o=this.getPrivateKey(s),h=Yt(o,n);return this.setSymKey(h,a)},this.setSymKey=async(s,n)=>{this.isInitialized();const a=n||Jt(s);return await this.keychain.set(a,s),a},this.deleteKeyPair=async s=>{this.isInitialized(),await this.keychain.del(s)},this.deleteSymKey=async s=>{this.isInitialized(),await this.keychain.del(s)},this.encode=async(s,n,a)=>{this.isInitialized();const o=Ht(a),h=Vt(n);if(De(o)){const k=o.senderPublicKey,H=o.receiverPublicKey;s=await this.generateSharedKey(k,H)}const l=this.getSymKey(s),{type:d,senderPublicKey:g}=o;return Xt({type:d,symKey:l,message:h,senderPublicKey:g})},this.decode=async(s,n,a)=>{this.isInitialized();const o=Wt(n,a);if(De(o)){const d=o.receiverPublicKey,g=o.senderPublicKey;s=await this.generateSharedKey(d,g)}const h=this.getSymKey(s),l=Zt({symKey:h,encoded:n});return qt(l)},this.core=e,this.logger=v(t,this.name),this.keychain=i||new Dt(this.core,this.logger)}get context(){return w(this.logger)}getPayloadType(e){const t=Qt(e);return ei(t.type)}async setPrivateKey(e,t){return await this.keychain.set(e,t),e}getPrivateKey(e){return this.keychain.get(e)}async getClientSeed(){let e="";try{e=this.keychain.get(ce)}catch{e=W(),await this.keychain.set(ce,e)}return Ys(e,"base16")}getSymKey(e){return this.keychain.get(e)}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class ft extends Ut{constructor(e,t){super(e,t),this.logger=e,this.core=t,this.messages=new Map,this.name=Je,this.version=He,this.initialized=!1,this.storagePrefix=x,this.init=async()=>{if(!this.initialized){this.logger.trace("Initialized");try{const i=await this.getRelayerMessages();typeof i<"u"&&(this.messages=i),this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",size:this.messages.size})}catch(i){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(i)}finally{this.initialized=!0}}},this.set=async(i,s)=>{this.isInitialized();const n=V(s);let a=this.messages.get(i);return typeof a>"u"&&(a={}),typeof a[n]<"u"||(a[n]=s,this.messages.set(i,a),await this.persist()),n},this.get=i=>{this.isInitialized();let s=this.messages.get(i);return typeof s>"u"&&(s={}),s},this.has=(i,s)=>{this.isInitialized();const n=this.get(i),a=V(s);return typeof n[a]<"u"},this.del=async i=>{this.isInitialized(),this.messages.delete(i),await this.persist()},this.logger=v(e,this.name),this.core=t}get context(){return w(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}async setRelayerMessages(e){await this.core.storage.setItem(this.storageKey,ge(e))}async getRelayerMessages(){const e=await this.core.storage.getItem(this.storageKey);return typeof e<"u"?pe(e):void 0}async persist(){await this.setRelayerMessages(this.messages)}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class Zs extends Ft{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,this.events=new z.EventEmitter,this.name=We,this.queue=new Map,this.publish=async(i,s,n)=>{this.logger.debug("Publishing Payload"),this.logger.trace({type:"method",method:"publish",params:{topic:i,message:s,opts:n}});try{const a=n?.ttl||Xe,o=Z(n),h=n?.prompt||!1,l=n?.tag||0,d={topic:i,message:s,opts:{ttl:a,relay:o,prompt:h,tag:l}},g=V(s);this.queue.set(g,d),await this.rpcPublish(i,s,a,o,h,l),this.onPublish(g,d),this.logger.debug("Successfully Published Payload"),this.logger.trace({type:"method",method:"publish",params:{topic:i,message:s,opts:n}})}catch(a){throw this.logger.debug("Failed to Publish Payload"),this.logger.error(a),a}},this.on=(i,s)=>{this.events.on(i,s)},this.once=(i,s)=>{this.events.once(i,s)},this.off=(i,s)=>{this.events.off(i,s)},this.removeListener=(i,s)=>{this.events.removeListener(i,s)},this.relayer=e,this.logger=v(t,this.name),this.registerEventListeners()}get context(){return w(this.logger)}rpcPublish(e,t,i,s,n,a){var o,h,l,d;const g={method:Q(s.protocol).publish,params:{topic:e,message:t,ttl:i,prompt:n,tag:a}};return ee((o=g.params)==null?void 0:o.prompt)&&((h=g.params)==null||delete h.prompt),ee((l=g.params)==null?void 0:l.tag)&&((d=g.params)==null||delete d.tag),this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"message",direction:"outgoing",request:g}),this.relayer.provider.request(g)}onPublish(e,t){this.queue.delete(e)}checkQueue(){this.queue.forEach(async e=>{const{topic:t,message:i,opts:{ttl:s,relay:n,prompt:a,tag:o}}=e,h=V(i);await this.rpcPublish(t,i,s,n,a,o),this.onPublish(h,e)})}registerEventListeners(){this.relayer.core.heartbeat.on(X.pulse,()=>{this.checkQueue()})}}class Qs{constructor(){this.map=new Map,this.set=(e,t)=>{const i=this.get(e);this.exists(e,t)||this.map.set(e,[...i,t])},this.get=e=>this.map.get(e)||[],this.exists=(e,t)=>this.get(e).includes(t),this.delete=(e,t)=>{if(typeof t>"u"){this.map.delete(e);return}if(!this.map.has(e))return;const i=this.get(e);if(!this.exists(e,t))return;const s=i.filter(n=>n!==t);if(!s.length){this.map.delete(e);return}this.map.set(e,s)},this.clear=()=>{this.map.clear()}}get topics(){return Array.from(this.map.keys())}}var er=Object.defineProperty,tr=Object.defineProperties,ir=Object.getOwnPropertyDescriptors,mt=Object.getOwnPropertySymbols,sr=Object.prototype.hasOwnProperty,rr=Object.prototype.propertyIsEnumerable,bt=(r,e,t)=>e in r?er(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Y=(r,e)=>{for(var t in e||(e={}))sr.call(e,t)&&bt(r,t,e[t]);if(mt)for(var t of mt(e))rr.call(e,t)&&bt(r,t,e[t]);return r},ue=(r,e)=>tr(r,ir(e));class Et extends Mt{constructor(e,t){super(e,t),this.relayer=e,this.logger=t,this.subscriptions=new Map,this.topicMap=new Qs,this.events=new z.EventEmitter,this.name=at,this.version=ot,this.pending=new Map,this.cached=[],this.initialized=!1,this.pendingSubscriptionWatchLabel="pending_sub_watch_label",this.pendingSubInterval=20,this.storagePrefix=x,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),await this.reset(),this.registerEventListeners(),this.onEnable())},this.subscribe=async(i,s)=>{this.isInitialized(),this.logger.debug("Subscribing Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:i,opts:s}});try{const n=Z(s),a={topic:i,relay:n};this.pending.set(i,a);const o=await this.rpcSubscribe(i,n);return this.onSubscribe(o,a),this.logger.debug("Successfully Subscribed Topic"),this.logger.trace({type:"method",method:"subscribe",params:{topic:i,opts:s}}),o}catch(n){throw this.logger.debug("Failed to Subscribe Topic"),this.logger.error(n),n}},this.unsubscribe=async(i,s)=>{this.isInitialized(),typeof s?.id<"u"?await this.unsubscribeById(i,s.id,s):await this.unsubscribeByTopic(i,s)},this.isSubscribed=async i=>this.topics.includes(i)?!0:await new Promise((s,n)=>{const a=new yi;a.start(this.pendingSubscriptionWatchLabel);const o=setInterval(()=>{!this.pending.has(i)&&this.topics.includes(i)&&(clearInterval(o),a.stop(this.pendingSubscriptionWatchLabel),s(!0)),a.elapsed(this.pendingSubscriptionWatchLabel)>=ht&&(clearInterval(o),a.stop(this.pendingSubscriptionWatchLabel),n(!1))},this.pendingSubInterval)}),this.on=(i,s)=>{this.events.on(i,s)},this.once=(i,s)=>{this.events.once(i,s)},this.off=(i,s)=>{this.events.off(i,s)},this.removeListener=(i,s)=>{this.events.removeListener(i,s)},this.relayer=e,this.logger=v(t,this.name)}get context(){return w(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}get length(){return this.subscriptions.size}get ids(){return Array.from(this.subscriptions.keys())}get values(){return Array.from(this.subscriptions.values())}get topics(){return this.topicMap.topics}hasSubscription(e,t){let i=!1;try{i=this.getSubscription(e).topic===t}catch{}return i}onEnable(){this.cached=[],this.initialized=!0}onDisable(){this.cached=this.values,this.subscriptions.clear(),this.topicMap.clear(),this.initialized=!1}async unsubscribeByTopic(e,t){const i=this.topicMap.get(e);await Promise.all(i.map(async s=>await this.unsubscribeById(e,s,t)))}async unsubscribeById(e,t,i){this.logger.debug("Unsubscribing Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:i}});try{const s=Z(i);await this.rpcUnsubscribe(e,t,s);const n=M("USER_DISCONNECTED",`${this.name}, ${e}`);await this.onUnsubscribe(e,t,n),this.logger.debug("Successfully Unsubscribed Topic"),this.logger.trace({type:"method",method:"unsubscribe",params:{topic:e,id:t,opts:i}})}catch(s){throw this.logger.debug("Failed to Unsubscribe Topic"),this.logger.error(s),s}}async rpcSubscribe(e,t){const i={method:Q(t.protocol).subscribe,params:{topic:e}};return this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:i}),await this.relayer.provider.request(i)}rpcUnsubscribe(e,t,i){const s={method:Q(i.protocol).unsubscribe,params:{topic:e,id:t}};return this.logger.debug("Outgoing Relay Payload"),this.logger.trace({type:"payload",direction:"outgoing",request:s}),this.relayer.provider.request(s)}onSubscribe(e,t){this.setSubscription(e,ue(Y({},t),{id:e})),this.pending.delete(t.topic)}onResubscribe(e,t){this.addSubscription(e,ue(Y({},t),{id:e})),this.pending.delete(t.topic)}async onUnsubscribe(e,t,i){this.events.removeAllListeners(t),this.hasSubscription(t,e)&&this.deleteSubscription(t,i),await this.relayer.messages.del(e)}async setRelayerSubscriptions(e){await this.relayer.core.storage.setItem(this.storageKey,e)}async getRelayerSubscriptions(){return await this.relayer.core.storage.getItem(this.storageKey)}setSubscription(e,t){this.subscriptions.has(e)||(this.logger.debug("Setting subscription"),this.logger.trace({type:"method",method:"setSubscription",id:e,subscription:t}),this.addSubscription(e,t))}addSubscription(e,t){this.subscriptions.set(e,Y({},t)),this.topicMap.set(t.topic,e),this.events.emit(O.created,t)}getSubscription(e){this.logger.debug("Getting subscription"),this.logger.trace({type:"method",method:"getSubscription",id:e});const t=this.subscriptions.get(e);if(!t){const{message:i}=c("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(i)}return t}deleteSubscription(e,t){this.logger.debug("Deleting subscription"),this.logger.trace({type:"method",method:"deleteSubscription",id:e,reason:t});const i=this.getSubscription(e);this.subscriptions.delete(e),this.topicMap.delete(i.topic,e),this.events.emit(O.deleted,ue(Y({},i),{reason:t}))}async persist(){await this.setRelayerSubscriptions(this.values),this.events.emit(O.sync)}async reset(){!this.cached.length||await Promise.all(this.cached.map(async e=>await this.resubscribe(e)))}async restore(){try{const e=await this.getRelayerSubscriptions();if(typeof e>"u"||!e.length)return;if(this.subscriptions.size){const{message:t}=c("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored subscriptions for ${this.name}`),this.logger.trace({type:"method",method:"restore",subscriptions:this.values})}catch(e){this.logger.debug(`Failed to Restore subscriptions for ${this.name}`),this.logger.error(e)}}async resubscribe(e){if(!this.ids.includes(e.id)){const{topic:t,relay:i}=e,s={topic:t,relay:i};this.pending.set(s.topic,s);const n=await this.rpcSubscribe(s.topic,s.relay);this.onResubscribe(n,s)}}async onConnect(){await this.reset(),this.onEnable()}onDisconnect(){this.onDisable()}checkPending(){this.pending.forEach(async e=>{const t=await this.rpcSubscribe(e.topic,e.relay);this.onSubscribe(t,e)})}registerEventListeners(){this.relayer.core.heartbeat.on(X.pulse,()=>{this.checkPending()}),this.relayer.provider.on(N.connect,async()=>{await this.onConnect()}),this.relayer.provider.on(N.disconnect,()=>{this.onDisconnect()}),this.events.on(O.created,async e=>{const t=O.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),await this.persist()}),this.events.on(O.deleted,async e=>{const t=O.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),await this.persist()})}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}var nr=Object.defineProperty,vt=Object.getOwnPropertySymbols,ar=Object.prototype.hasOwnProperty,or=Object.prototype.propertyIsEnumerable,wt=(r,e,t)=>e in r?nr(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,hr=(r,e)=>{for(var t in e||(e={}))ar.call(e,t)&&wt(r,t,e[t]);if(vt)for(var t of vt(e))or.call(e,t)&&wt(r,t,e[t]);return r};class _t extends $t{constructor(e){super(e),this.protocol="wc",this.version=2,this.events=new z.EventEmitter,this.name=tt,this.initialized=!1,this.core=e.core,this.logger=typeof e.logger<"u"&&typeof e.logger!="string"?v(e.logger,this.name):le(de({level:e.logger||Qe})),this.messages=new ft(this.logger,e.core),this.subscriber=new Et(this,this.logger),this.publisher=new Zs(this,this.logger),this.relayUrl=e?.relayUrl||et,this.projectId=e.projectId,this.provider={}}async init(){this.logger.trace("Initialized");const e=await this.core.crypto.signJWT(this.relayUrl);this.provider=this.createProvider(e),await Promise.all([this.messages.init(),this.provider.connect(),this.subscriber.init()]),this.registerEventListeners(),this.initialized=!0}get context(){return w(this.logger)}get connected(){return this.provider.connection.connected}get connecting(){return this.provider.connection.connecting}async publish(e,t,i){this.isInitialized(),await this.publisher.publish(e,t,i),await this.recordMessageEvent({topic:e,message:t})}async subscribe(e,t){return this.isInitialized(),await this.subscriber.subscribe(e,t)}async unsubscribe(e,t){this.isInitialized(),await this.subscriber.unsubscribe(e,t)}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}off(e,t){this.events.off(e,t)}removeListener(e,t){this.events.removeListener(e,t)}createProvider(e){return new fi(new vi(ti({sdkVersion:rt,protocol:this.protocol,version:this.version,relayUrl:this.relayUrl,projectId:this.projectId,auth:e})))}async recordMessageEvent(e){const{topic:t,message:i}=e;await this.messages.set(t,i)}async shouldIgnoreMessageEvent(e){const{topic:t,message:i}=e;return await this.subscriber.isSubscribed(t)?this.messages.has(t,i):!0}async onProviderPayload(e){if(this.logger.debug("Incoming Relay Payload"),this.logger.trace({type:"payload",direction:"incoming",payload:e}),Ee(e)){if(!e.method.endsWith(it))return;const t=e.params,{topic:i,message:s}=t.data,n={topic:i,message:s};this.logger.debug("Emitting Relayer Payload"),this.logger.trace(hr({type:"event",event:t.id},n)),this.events.emit(t.id,n),await this.acknowledgePayload(e),await this.onMessageEvent(n)}}async onMessageEvent(e){await this.shouldIgnoreMessageEvent(e)||(this.events.emit(U.message,e),await this.recordMessageEvent(e))}async acknowledgePayload(e){const t=ve(e.id,!0);await this.provider.connection.send(t)}registerEventListeners(){this.provider.on(N.payload,e=>this.onProviderPayload(e)),this.provider.on(N.connect,()=>{this.events.emit(U.connect)}),this.provider.on(N.disconnect,()=>{this.events.emit(U.disconnect),setTimeout(()=>{this.provider.connect()},me(st))}),this.provider.on(N.error,e=>this.events.emit(U.error,e))}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}var cr=Object.defineProperty,It=Object.getOwnPropertySymbols,ur=Object.prototype.hasOwnProperty,lr=Object.prototype.propertyIsEnumerable,Ct=(r,e,t)=>e in r?cr(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Rt=(r,e)=>{for(var t in e||(e={}))ur.call(e,t)&&Ct(r,t,e[t]);if(It)for(var t of It(e))lr.call(e,t)&&Ct(r,t,e[t]);return r};class St extends Kt{constructor(e,t,i,s=x,n=void 0){super(e,t,i,s),this.core=e,this.logger=t,this.name=i,this.map=new Map,this.version=nt,this.cached=[],this.initialized=!1,this.storagePrefix=x,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(a=>{ii(a)?this.map.set(a.id,a):si(a)?this.map.set(a.topic,a):this.getKey&&a!==null&&!ee(a)&&this.map.set(this.getKey(a),a)}),this.cached=[],this.initialized=!0)},this.set=async(a,o)=>{this.isInitialized(),this.map.has(a)?await this.update(a,o):(this.logger.debug("Setting value"),this.logger.trace({type:"method",method:"set",key:a,value:o}),this.map.set(a,o),await this.persist())},this.get=a=>(this.isInitialized(),this.logger.debug("Getting value"),this.logger.trace({type:"method",method:"get",key:a}),this.getData(a)),this.getAll=a=>(this.isInitialized(),a?this.values.filter(o=>Object.keys(a).every(h=>wi(o[h],a[h]))):this.values),this.update=async(a,o)=>{this.isInitialized(),this.logger.debug("Updating value"),this.logger.trace({type:"method",method:"update",key:a,update:o});const h=Rt(Rt({},this.getData(a)),o);this.map.set(a,h),await this.persist()},this.delete=async(a,o)=>{this.isInitialized(),this.map.has(a)&&(this.logger.debug("Deleting value"),this.logger.trace({type:"method",method:"delete",key:a,reason:o}),this.map.delete(a),await this.persist())},this.logger=v(t,this.name),this.storagePrefix=s,this.getKey=n}get context(){return w(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}get length(){return this.map.size}get keys(){return Array.from(this.map.keys())}get values(){return Array.from(this.map.values())}async setDataStore(e){await this.core.storage.setItem(this.storageKey,e)}async getDataStore(){return await this.core.storage.getItem(this.storageKey)}getData(e){const t=this.map.get(e);if(!t){const{message:i}=c("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.error(i),new Error(i)}return t}async persist(){await this.setDataStore(this.values)}async restore(){try{const e=await this.getDataStore();if(typeof e>"u"||!e.length)return;if(this.map.size){const{message:t}=c("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored value for ${this.name}`),this.logger.trace({type:"method",method:"restore",value:this.values})}catch(e){this.logger.debug(`Failed to Restore value for ${this.name}`),this.logger.error(e)}}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class Tt{constructor(e,t){this.core=e,this.logger=t,this.name=ct,this.version=ut,this.events=new z,this.initialized=!1,this.storagePrefix=x,this.ignoredPayloadTypes=[ri],this.registeredMethods=[],this.init=async()=>{this.initialized||(await this.pairings.init(),await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.initialized=!0,this.logger.trace("Initialized"))},this.register=({methods:i})=>{this.isInitialized(),this.registeredMethods=[...new Set([...this.registeredMethods,...i])]},this.create=async()=>{this.isInitialized();const i=W(),s=await this.core.crypto.setSymKey(i),n=te(be),a={protocol:Ze},o={topic:s,expiry:n,relay:a,active:!1},h=ni({protocol:this.core.protocol,version:this.core.version,topic:s,symKey:i,relay:a});return await this.pairings.set(s,o),await this.core.relayer.subscribe(s),this.core.expirer.set(s,n),{topic:s,uri:h}},this.pair=async i=>{this.isInitialized(),this.isValidPair(i);const{topic:s,symKey:n,relay:a}=ai(i.uri),o=te(be),h={topic:s,relay:a,expiry:o,active:!1};return await this.pairings.set(s,h),await this.core.crypto.setSymKey(n,s),await this.core.relayer.subscribe(s,{relay:a}),this.core.expirer.set(s,o),i.activatePairing&&await this.activate({topic:s}),h},this.activate=async({topic:i})=>{this.isInitialized();const s=te(re);await this.pairings.update(i,{active:!0,expiry:s}),this.core.expirer.set(i,s)},this.ping=async i=>{this.isInitialized(),await this.isValidPing(i);const{topic:s}=i;if(this.pairings.keys.includes(s)){const n=await this.sendRequest(s,"wc_pairingPing",{}),{done:a,resolve:o,reject:h}=oi();this.events.once(ie("pairing_ping",n),({error:l})=>{l?h(l):o()}),await a()}},this.updateExpiry=async({topic:i,expiry:s})=>{this.isInitialized(),await this.pairings.update(i,{expiry:s})},this.updateMetadata=async({topic:i,metadata:s})=>{this.isInitialized(),await this.pairings.update(i,{peerMetadata:s})},this.getPairings=()=>(this.isInitialized(),this.pairings.values),this.disconnect=async i=>{this.isInitialized(),await this.isValidDisconnect(i);const{topic:s}=i;this.pairings.keys.includes(s)&&(await this.sendRequest(s,"wc_pairingDelete",M("USER_DISCONNECTED")),await this.deletePairing(s))},this.sendRequest=async(i,s,n)=>{const a=we(s,n),o=await this.core.crypto.encode(i,a),h=F[s].req;return this.core.history.set(i,a),await this.core.relayer.publish(i,o,h),a.id},this.sendResult=async(i,s,n)=>{const a=ve(i,n),o=await this.core.crypto.encode(s,a),h=await this.core.history.get(s,i),l=F[h.request.method].res;await this.core.relayer.publish(s,o,l),await this.core.history.resolve(a)},this.sendError=async(i,s,n)=>{const a=mi(i,n),o=await this.core.crypto.encode(s,a),h=await this.core.history.get(s,i),l=F[h.request.method]?F[h.request.method].res:F.unregistered_method.res;await this.core.relayer.publish(s,o,l),await this.core.history.resolve(a)},this.deletePairing=async(i,s)=>{await this.core.relayer.unsubscribe(i),await Promise.all([this.pairings.delete(i,M("USER_DISCONNECTED")),this.core.crypto.deleteSymKey(i),s?Promise.resolve():this.core.expirer.del(i)])},this.cleanup=async()=>{const i=this.pairings.getAll().filter(s=>ye(s.expiry));await Promise.all(i.map(s=>this.deletePairing(s.topic)))},this.onRelayEventRequest=i=>{const{topic:s,payload:n}=i;switch(n.method){case"wc_pairingPing":return this.onPairingPingRequest(s,n);case"wc_pairingDelete":return this.onPairingDeleteRequest(s,n);default:return this.onUnknownRpcMethodRequest(s,n)}},this.onRelayEventResponse=async i=>{const{topic:s,payload:n}=i,a=(await this.core.history.get(s,n.id)).request.method;switch(a){case"wc_pairingPing":return this.onPairingPingResponse(s,n);default:return this.onUnknownRpcMethodResponse(a)}},this.onPairingPingRequest=async(i,s)=>{const{id:n}=s;try{this.isValidPing({topic:i}),await this.sendResult(n,i,!0),this.events.emit("pairing_ping",{id:n,topic:i})}catch(a){await this.sendError(n,i,a),this.logger.error(a)}},this.onPairingPingResponse=(i,s)=>{const{id:n}=s;setTimeout(()=>{bi(s)?this.events.emit(ie("pairing_ping",n),{}):_e(s)&&this.events.emit(ie("pairing_ping",n),{error:s.error})},500)},this.onPairingDeleteRequest=async(i,s)=>{const{id:n}=s;try{this.isValidDisconnect({topic:i}),await this.sendResult(n,i,!0),await this.deletePairing(i),this.events.emit("pairing_delete",{id:n,topic:i})}catch(a){await this.sendError(n,i,a),this.logger.error(a)}},this.onUnknownRpcMethodRequest=async(i,s)=>{const{id:n,method:a}=s;try{if(this.registeredMethods.includes(a))return;const o=M("WC_METHOD_UNSUPPORTED",a);await this.sendError(n,i,o),this.logger.error(o)}catch(o){await this.sendError(n,i,o),this.logger.error(o)}},this.onUnknownRpcMethodResponse=i=>{this.registeredMethods.includes(i)||this.logger.error(M("WC_METHOD_UNSUPPORTED",i))},this.isValidPair=i=>{if(!se(i)){const{message:s}=c("MISSING_OR_INVALID",`pair() params: ${i}`);throw new Error(s)}if(!hi(i.uri)){const{message:s}=c("MISSING_OR_INVALID",`pair() uri: ${i.uri}`);throw new Error(s)}},this.isValidPing=async i=>{if(!se(i)){const{message:n}=c("MISSING_OR_INVALID",`ping() params: ${i}`);throw new Error(n)}const{topic:s}=i;await this.isValidPairingTopic(s)},this.isValidDisconnect=async i=>{if(!se(i)){const{message:n}=c("MISSING_OR_INVALID",`disconnect() params: ${i}`);throw new Error(n)}const{topic:s}=i;await this.isValidPairingTopic(s)},this.isValidPairingTopic=async i=>{if(!ci(i,!1)){const{message:s}=c("MISSING_OR_INVALID",`pairing topic should be a string: ${i}`);throw new Error(s)}if(!this.pairings.keys.includes(i)){const{message:s}=c("NO_MATCHING_KEY",`pairing topic doesn't exist: ${i}`);throw new Error(s)}if(ye(this.pairings.get(i).expiry)){await this.deletePairing(i);const{message:s}=c("EXPIRED",`pairing topic: ${i}`);throw new Error(s)}},this.core=e,this.logger=v(t,this.name),this.pairings=new St(this.core,this.logger,this.name,this.storagePrefix)}get context(){return w(this.logger)}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}registerRelayerEvents(){this.core.relayer.on(U.message,async e=>{const{topic:t,message:i}=e;if(this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i)))return;const s=await this.core.crypto.decode(t,i);Ee(s)?(this.core.history.set(t,s),this.onRelayEventRequest({topic:t,payload:s})):Ei(s)&&(await this.core.history.resolve(s),this.onRelayEventResponse({topic:t,payload:s}))})}registerExpirerEvents(){this.core.expirer.on(m.expired,async e=>{const{topic:t}=ui(e.target);t&&this.pairings.keys.includes(t)&&(await this.deletePairing(t,!0),this.events.emit("pairing_expire",{topic:t}))})}}class xt extends kt{constructor(e,t){super(e,t),this.core=e,this.logger=t,this.records=new Map,this.events=new z.EventEmitter,this.name=lt,this.version=dt,this.cached=[],this.initialized=!1,this.storagePrefix=x,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(i=>this.records.set(i.id,i)),this.cached=[],this.registerEventListeners(),this.initialized=!0)},this.set=(i,s,n)=>{if(this.isInitialized(),this.logger.debug("Setting JSON-RPC request history record"),this.logger.trace({type:"method",method:"set",topic:i,request:s,chainId:n}),this.records.has(s.id))return;const a={id:s.id,topic:i,request:{method:s.method,params:s.params||null},chainId:n};this.records.set(a.id,a),this.events.emit(_.created,a)},this.resolve=async i=>{if(this.isInitialized(),this.logger.debug("Updating JSON-RPC response history record"),this.logger.trace({type:"method",method:"update",response:i}),!this.records.has(i.id))return;const s=await this.getRecord(i.id);typeof s.response>"u"&&(s.response=_e(i)?{error:i.error}:{result:i.result},this.records.set(s.id,s),this.events.emit(_.updated,s))},this.get=async(i,s)=>(this.isInitialized(),this.logger.debug("Getting record"),this.logger.trace({type:"method",method:"get",topic:i,id:s}),await this.getRecord(s)),this.delete=(i,s)=>{this.isInitialized(),this.logger.debug("Deleting record"),this.logger.trace({type:"method",method:"delete",id:s}),this.values.forEach(n=>{if(n.topic===i){if(typeof s<"u"&&n.id!==s)return;this.records.delete(n.id),this.events.emit(_.deleted,n)}})},this.exists=async(i,s)=>(this.isInitialized(),this.records.has(s)?(await this.getRecord(s)).topic===i:!1),this.on=(i,s)=>{this.events.on(i,s)},this.once=(i,s)=>{this.events.once(i,s)},this.off=(i,s)=>{this.events.off(i,s)},this.removeListener=(i,s)=>{this.events.removeListener(i,s)},this.logger=v(t,this.name)}get context(){return w(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}get size(){return this.records.size}get keys(){return Array.from(this.records.keys())}get values(){return Array.from(this.records.values())}get pending(){const e=[];return this.values.forEach(t=>{if(typeof t.response<"u")return;const i={topic:t.topic,request:we(t.request.method,t.request.params,t.id),chainId:t.chainId};return e.push(i)}),e}async setJsonRpcRecords(e){await this.core.storage.setItem(this.storageKey,e)}async getJsonRpcRecords(){return await this.core.storage.getItem(this.storageKey)}getRecord(e){this.isInitialized();const t=this.records.get(e);if(!t){const{message:i}=c("NO_MATCHING_KEY",`${this.name}: ${e}`);throw new Error(i)}return t}async persist(){await this.setJsonRpcRecords(this.values),this.events.emit(_.sync)}async restore(){try{const e=await this.getJsonRpcRecords();if(typeof e>"u"||!e.length)return;if(this.records.size){const{message:t}=c("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored records for ${this.name}`),this.logger.trace({type:"method",method:"restore",records:this.values})}catch(e){this.logger.debug(`Failed to Restore records for ${this.name}`),this.logger.error(e)}}registerEventListeners(){this.events.on(_.created,e=>{const t=_.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e}),this.persist()}),this.events.on(_.updated,e=>{const t=_.updated;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e}),this.persist()}),this.events.on(_.deleted,e=>{const t=_.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,record:e}),this.persist()})}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}class Pt extends Bt{constructor(e,t){super(e,t),this.core=e,this.logger=t,this.expirations=new Map,this.events=new z.EventEmitter,this.name=gt,this.version=pt,this.cached=[],this.initialized=!1,this.storagePrefix=x,this.init=async()=>{this.initialized||(this.logger.trace("Initialized"),await this.restore(),this.cached.forEach(i=>this.expirations.set(i.target,i)),this.cached=[],this.registerEventListeners(),this.initialized=!0)},this.has=i=>{try{const s=this.formatTarget(i);return typeof this.getExpiration(s)<"u"}catch{return!1}},this.set=(i,s)=>{this.isInitialized();const n=this.formatTarget(i),a={target:n,expiry:s};this.expirations.set(n,a),this.checkExpiry(n,a),this.events.emit(m.created,{target:n,expiration:a})},this.get=i=>{this.isInitialized();const s=this.formatTarget(i);return this.getExpiration(s)},this.del=i=>{this.isInitialized();const s=this.formatTarget(i);if(this.has(s)){const n=this.getExpiration(s);this.expirations.delete(s),this.events.emit(m.deleted,{target:s,expiration:n})}},this.on=(i,s)=>{this.events.on(i,s)},this.once=(i,s)=>{this.events.once(i,s)},this.off=(i,s)=>{this.events.off(i,s)},this.removeListener=(i,s)=>{this.events.removeListener(i,s)},this.logger=v(t,this.name)}get context(){return w(this.logger)}get storageKey(){return this.storagePrefix+this.version+"//"+this.name}get length(){return this.expirations.size}get keys(){return Array.from(this.expirations.keys())}get values(){return Array.from(this.expirations.values())}formatTarget(e){if(typeof e=="string")return li(e);if(typeof e=="number")return di(e);const{message:t}=c("UNKNOWN_TYPE",`Target type: ${typeof e}`);throw new Error(t)}async setExpirations(e){await this.core.storage.setItem(this.storageKey,e)}async getExpirations(){return await this.core.storage.getItem(this.storageKey)}async persist(){await this.setExpirations(this.values),this.events.emit(m.sync)}async restore(){try{const e=await this.getExpirations();if(typeof e>"u"||!e.length)return;if(this.expirations.size){const{message:t}=c("RESTORE_WILL_OVERRIDE",this.name);throw this.logger.error(t),new Error(t)}this.cached=e,this.logger.debug(`Successfully Restored expirations for ${this.name}`),this.logger.trace({type:"method",method:"restore",expirations:this.values})}catch(e){this.logger.debug(`Failed to Restore expirations for ${this.name}`),this.logger.error(e)}}getExpiration(e){const t=this.expirations.get(e);if(!t){const{message:i}=c("NO_MATCHING_KEY",`${this.name}: ${e}`);throw this.logger.error(i),new Error(i)}return t}checkExpiry(e,t){const{expiry:i}=t;me(i)-Date.now()<=0&&this.expire(e,t)}expire(e,t){this.expirations.delete(e),this.events.emit(m.expired,{target:e,expiration:t})}checkExpirations(){this.expirations.forEach((e,t)=>this.checkExpiry(t,e))}registerEventListeners(){this.core.heartbeat.on(X.pulse,()=>this.checkExpirations()),this.events.on(m.created,e=>{const t=m.created;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}),this.events.on(m.expired,e=>{const t=m.expired;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()}),this.events.on(m.deleted,e=>{const t=m.deleted;this.logger.info(`Emitting ${t}`),this.logger.debug({type:"event",event:t,data:e}),this.persist()})}isInitialized(){if(!this.initialized){const{message:e}=c("NOT_INITIALIZED",this.name);throw new Error(e)}}}var dr=Object.defineProperty,Ot=Object.getOwnPropertySymbols,gr=Object.prototype.hasOwnProperty,pr=Object.prototype.propertyIsEnumerable,At=(r,e,t)=>e in r?dr(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,zt=(r,e)=>{for(var t in e||(e={}))gr.call(e,t)&&At(r,t,e[t]);if(Ot)for(var t of Ot(e))pr.call(e,t)&&At(r,t,e[t]);return r};class J extends jt{constructor(e){super(e),this.protocol=he,this.version=ke,this.name=G,this.events=new z.EventEmitter,this.initialized=!1,this.on=(i,s)=>this.events.on(i,s),this.once=(i,s)=>this.events.once(i,s),this.off=(i,s)=>this.events.off(i,s),this.removeListener=(i,s)=>this.events.removeListener(i,s),this.projectId=e?.projectId;const t=typeof e?.logger<"u"&&typeof e?.logger!="string"?e.logger:le(de({level:e?.logger||Be.logger}));this.logger=v(t,this.name),this.heartbeat=new Lt,this.crypto=new yt(this,this.logger,e?.keychain),this.history=new xt(this,this.logger),this.expirer=new Pt(this,this.logger),this.storage=e!=null&&e.storage?e.storage:new Nt(zt(zt({},je),e?.storageOptions)),this.relayer=new _t({core:this,logger:this.logger,relayUrl:e?.relayUrl,projectId:this.projectId}),this.pairing=new Tt(this,this.logger)}static async init(e){const t=new J(e);return await t.initialize(),t}get context(){return w(this.logger)}async start(){this.initialized||await this.initialize()}async initialize(){this.logger.trace("Initialized");try{await this.crypto.init(),await this.history.init(),await this.expirer.init(),await this.relayer.init(),await this.heartbeat.init(),await this.pairing.init(),this.initialized=!0,this.logger.info("Core Initilization Success")}catch(e){throw this.logger.warn(`Core Initilization Failure at epoch ${Date.now()}`,e),this.logger.error(e.message),e}}}const Dr=J;export{G as CORE_CONTEXT,Be as CORE_DEFAULT,he as CORE_PROTOCOL,je as CORE_STORAGE_OPTIONS,x as CORE_STORAGE_PREFIX,ke as CORE_VERSION,ce as CRYPTO_CLIENT_SEED,Ve as CRYPTO_CONTEXT,qe as CRYPTO_JWT_TTL,Dr as Core,yt as Crypto,gt as EXPIRER_CONTEXT,Ws as EXPIRER_DEFAULT_TTL,m as EXPIRER_EVENTS,pt as EXPIRER_STORAGE_VERSION,Pt as Expirer,lt as HISTORY_CONTEXT,_ as HISTORY_EVENTS,dt as HISTORY_STORAGE_VERSION,xt as JsonRpcHistory,Ge as KEYCHAIN_CONTEXT,Ye as KEYCHAIN_STORAGE_VERSION,Dt as KeyChain,Je as MESSAGES_CONTEXT,He as MESSAGES_STORAGE_VERSION,ft as MessageTracker,ct as PAIRING_CONTEXT,Xs as PAIRING_DEFAULT_TTL,F as PAIRING_RPC_OPTS,ut as PAIRING_STORAGE_VERSION,ht as PENDING_SUB_RESOLUTION_TIMEOUT,We as PUBLISHER_CONTEXT,Xe as PUBLISHER_DEFAULT_TTL,Tt as Pairing,tt as RELAYER_CONTEXT,Qe as RELAYER_DEFAULT_LOGGER,Ze as RELAYER_DEFAULT_PROTOCOL,et as RELAYER_DEFAULT_RELAY_URL,U as RELAYER_EVENTS,N as RELAYER_PROVIDER_EVENTS,st as RELAYER_RECONNECT_TIMEOUT,rt as RELAYER_SDK_VERSION,Js as RELAYER_STORAGE_OPTIONS,it as RELAYER_SUBSCRIBER_SUFFIX,_t as Relayer,nt as STORE_STORAGE_VERSION,at as SUBSCRIBER_CONTEXT,Hs as SUBSCRIBER_DEFAULT_TTL,O as SUBSCRIBER_EVENTS,ot as SUBSCRIBER_STORAGE_VERSION,St as Store,Et as Subscriber,J as default};
//# sourceMappingURL=index.es.js.map
